Алгоритмом называется набор инструкций для выполнения некоторой задачи.

Бинарный поиск:
обычный n
бинарный log(2)n

O(log n) -> O(n) -> O(n * log n) -> O(n^2) -> O(n!)

				get      					    add     				   remove
Array 	   		O(1)							O(n)						O(n)	      находится в памяти последовательно
Linked List  (O(n). get(0) get(last) (O(1))     O(1)						O(1)	      разбросан по памяти, имеет ссылку на следующий элемент
Hash Table    сред = O(1), худ = O(n)			ср = O(1), ху = O(n)		ср = O(1), ху = O(n)
BinarySearchTree O(log n)						O(log n)					O(log n)	  сюда же относятся AVL, Splay, Red-Black. Это всё в лучшем случае, в худшем O(n) у несбалансированного, в общем случае O(h)

Методы со всеми их переменными складываются в памяти стеком

Доказательство по индукции: начальная ступень, возможность перехода ко второй ступени, к третьей и так далее.

сортировка слиянием n * log n
быстрая сортировка n * log n в лучшем и среднем и n^2 в худшем случаях. Но константа у n * log n меньше, чем у сорт. слиянием, поэтому она быстрее.
	если опорным элементом всегда выбирать случайный элемент, то в среднем сортировка будет выполняться за n * log n.
	
Стратегия "Разделяй и властвуй" основана на разбиении задачи на уменьшающиеся фрагменты. Базовый случай - самый маленький элемент.

MAP:
хэш-таблица = массив + хэш-функция

хэш-таблица = ассоциативный массив = словарь = отображение = хэш карта = хэш

ключ мапы превращается в число, чтобы найти ячейку, куда положить или вытащить значение

последовательная хэш-функция - функция, которая для одних и тех же значений выдаёт один и тот же результат
хэш-функция полезно иметь много разных значений, а не только единицу, например
В идеале хеш-функция должна распределять ключи равномерно по всему хешу.
Хэш функции должны уметь выдавать огромный диапазон значений, но одно и то же значение для одного и того же объекта.

Map должна пересоздавать массив при коэффициенте заполнения 0.7 (7 ячеек из 10 заняты)

хэш-таблицы нужны для следующих задач:
1) моделирование отношений между объектами;
2) устранение дубликатов;
3) кэширование/запоминание данных вместо выполнения работы на сервере.

коллизия - двум элементам назначается одна и та же ячейка после вычисления хэша

Хеш-таблицы используются для кэширования данных (например, на веб-серверах).

ГРАФЫ:

ориентированные, неориентированные, взвешенный (есть весы, цена перехода к следующему узлу, цифра над ребром), невзвешенный
Алгоритм Дейкстры работает только для неотрицательных взвешенных однонаправленных графов.
Алгоритм Беллмана - Форда для вычисление кратчайшего пути в графе, содержащего рёбра с отрицательным весом.

Поиск в ширину (BFS, Breadth-First Search) решает задачу поиска кратчайшего пути и есть ли такой путь вообще в невзвешенных графах.

Поиск в глубину (DFS, Depth-Fist Search). Цель: обойти все вершины графа. Попадаем в начальную вершину, помечаем её как пройденную, 
идём в его любого соседа, также помечаем, так до тех пор, пока не будет ни одного непомеченного соседа. Возвращаемся обратно 
и проверяем каждый раз, нет ли ещё непомеченные соседи. Так до сих пор, пока не окажемся в начальной вершине, у которой не будет 
непомеченных соседей.

Алгоритм Дейкстры решает задачу кратчайшего пути во взвешенных графах

Поиск в ширину отвечает на 2 вопрос:
1) существует ли путь от узла А к узлу В? (Есть ли продавец манго в вашей сети?);
2) как выглядит кратчайший путь от узла А к узлу В? (Кто из продавцов манго находится ближе всего к вам?).

Поиск в ширину - это когда ты ищешь информацию у друзей, друзей друзей и т.д. пока не найдёшь информацию, или пока сеть друзей не закончится.
Связи 1 уровня (друзья) выполняются раньше связей 2 уровня (друзья другзей) и т.д.

<!--
Кладёшь в мапу себя как ключ и всех твоих друзей как значение
Добавляешь в очередь всех своих друзей
Далее пробегаемся по очереди:
если человек в очереди является продавцом манго - возвращаем всё что нужно
если человек в очереди не является продавцом манго - добавляем в очередь всех его друзей
(создал этот алгоритм в Intellij Idea)
-->

O(V+E) - вершины + рёбра, так как в худшем случае алгоритм BFS проходит по всем вершинам и всем рёбрам.

Топологическая сортировка на основе действительного графа. Действительный граф, это когда закрашиваешь его иключительно по рёбрам, 
но при этом можно менять задачу в другом месте закраски.

Дерево - граф, у которого все рёбра направлены в одном направлении.

Бинарное дерево поиска:
1) Оба поддерева являются бинарными деревьями поиска.
2) Каждый левый потомок имеет ключи <= а правый >, чем у узла родителя.

Двоичное дерево поиска. У каждой вершины не больше 2 детей и значения у ребёнка слева меньше, чем у него, а справа больше, чем у него.

search, add and remove O(log n);
Нелья получить i-ый элемент.

Красно-Чёрное дерево - самобалансировка.
1) Каждый узел окрашен либо в красный, либо в черный цвет (в структуре данных узла появляется дополнительное поле – бит цвета).
2) Корень окрашен в черный цвет.
3) Листья(так называемые NULL-узлы) окрашены в черный цвет.
4) Каждый красный узел должен иметь два черных дочерних узла. Нужно отметить, что у черного узла могут быть черные дочерние узлы. 
	Красные узлы в качестве дочерних могут иметь только черные.
5) Пути от узла к его листьям должны содержать одинаковое количество черных узлов(это черная высота).

Ещё бывают B-деревья, красно-чёрные деревья, кучи, splay деревья.

вырожденное дерево - дерево с максимальной высотой, выстраивается в линию вниз.

Инвентированный индекс - хэш-таблица. Ключ - слово, значение - список страниц, где это слово встречается. Так работают поисковые системы.

Линейной программирование - задачи на оптимизацию.

sha-0 sha-1 sha-2 sha-3 bcrypt - хэш-функции
Simhash генерирует близкие хэш-коды у близких значений, используется для выявления сходства между фрагментами текста.

AVL-tree (O(log n) в среднем и худшем случае). Расход памяти (O(n) в среднем и худшем случае)
Поиск: спускаемся от корня пока не найдём ключ или не будет места.
Вставка: поиск и если не нашли, то вставляем
Удаление: если лист (нет детей), то просто отрезаем. Если один ребёнок, то удаляем его, а его ребёнка подвешиваем к дедушке,
	если два ребёнка, то меняем местами с самым большим элементом в левом поддереве и удаляем как лист.
Min элемент в самом левом, Max - в самом правом.
O(высоты дерева), то есть при балансировке O(log n)
Балансировака вращениями. В каждой вершине хранить информация о высоте её поддерева. Чиним свойство, поднимаясь вверх.

Splay-tree (O(log n) в среднем и худшем случае). Расход памяти (O(n) в среднем и худшем случае)
При поиске и вставке вызывается splay(), который за логарифмическое время выведет вершину наверх.
Разбиение (split) делается путём вывода какого-либо элемента вверх и отсоединение одного из поддеревьев.
Слияние (merge) при разбиении левое поддерево вытаскивает вверх самый большой элемент и присоединяет справа второе поддерево
Удаление (remove) выполняется путём вывода определённого элемента наверх, после чего удаляется,а два разделённых дерева объединяются.

Сортировка в java Arrays.sort():

Implementation note: The sorting algorithm is a Dual-Pivot Quicksort
     * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm
     * offers O(n log(n)) performance on many data sets that cause other
     * quicksorts to degrade to quadratic performance, and is typically
     * faster than traditional (one-pivot) Quicksort implementations.
	 
	 
Быстрая сортировка с двойным пивотом. На маленьких массивах используется сортировка вставками. Также используется pair insertion sort

Если массив маленький, то он сортируется вставками. Берётся два пивота (точки опоры), чтобы собирать между ними одинаковые элементы, Use counting sort on large arrays

Что значит O(f(n))?
Формально O(f(n)) означает, что время работы алгоритма (или объём занимаемой памяти) растёт в зависимости от объёма входных данных не быстрее, чем некоторая константа, умноженная на f(n).
При входном потоке n время работы алгоритма растёт не быстрее, чем const * f(n).