 
 Java Visual VM <--- можно подключаться к существующим java-процессам и получать инфу о них

 Свойства класса, помеченные модификатором transient, не сериализуются.
  Обычно в таких полях хранится промежуточное состояние объекта, которое, к примеру, проще вычислить, чем сериализовать, а затем десериализавать. 
  Другой пример такого поля - ссылка на экземпляр объекта, который не требует сериализации или не может быть сериализован.


В рунтайме jvm может иметь 6-ть областей памяти. 
Области уникальные для каждого потока: 
 1. pc (program counter) - разные указатели и мета-информация о потоке 
 2. jvm stack - то что мы и привыкли называть стеком, здесь хранятся фреймы (инфа о текущем запущенном методе) 
 3. Native Method Stacks - отдельный стек для нативных методов 
Общие области: 
 4. Heap - хранилище объектов и область владения сборщика мусора 
 5. Method Area - хранит структуры каждого класса, такие как пул постоянной времени ( run-time constant pool) выполнения, данные полей и методов, а также код методов и конструкторов, 
	 включая специальные методы, используемые при инициализации класса и экземпляра и инициализации интерфейса! И самое интересное! Метод Эриа может как обрабатываться сборщиком так и нет! 
	 Если нет она будет очищена после инициализации классов и запуска программы. 
 6. Run-Time Constant Pool - да, оказывается для всех пулов (String pool, Integer pool и тд) есть отдельная область памяти! 

Путаница возникает когда начинают смешивать понятия "область памяти" и "области работы сборщика мусора" Основная область обитания GC - heap, именно пространство хипа он условно делит для себя 
на young и tenured дженерэйшен. И вот тут фокус покус: если мы разрешаем GC лезть в область Method Area от GC ставит галочку для себя мол это отдельное пространство за которым он должен следить 
и для себя он отмечает это отдельное пространство как Methaspace или иначе - Class Metadata. В Class Metadata кроме Method Area, ещё входит информация о том что находится в Run-Time Constant Pool. 
И в целом говорить о том что heap делится на tenured и young дженерэйшн не совсем корректно. Heap не на что не делится. А вот при работе с 'неделимым' хипом GC помечает для себя отдельные области 
(это GC для себя делит хип) как tenured и young дженерэйшн. Точно также Methaspace - это некое название которым пользуется GC. И такой области памяти нет. Поправьте если я что-то неправильно понимаю. 
https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5 
https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#sthref16 
https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/considerations.html#sthref62
